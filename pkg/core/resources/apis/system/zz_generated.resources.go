// Generated by tools/resource-gen.
// Run "make generate" to update this file.

// nolint:whitespace
package system

import (
	"fmt"

	system_proto "github.com/apache/dubbo-kubernetes/api/system/v1alpha1"
	"github.com/apache/dubbo-kubernetes/pkg/core/resources/model"
	"github.com/apache/dubbo-kubernetes/pkg/core/resources/registry"
)

const (
	ConfigType model.ResourceType = "Config"
)

var _ model.Resource = &ConfigResource{}

type ConfigResource struct {
	Meta model.ResourceMeta
	Spec *system_proto.Config
}

func NewConfigResource() *ConfigResource {
	return &ConfigResource{
		Spec: &system_proto.Config{},
	}
}

func (t *ConfigResource) GetMeta() model.ResourceMeta {
	return t.Meta
}

func (t *ConfigResource) SetMeta(m model.ResourceMeta) {
	t.Meta = m
}

func (t *ConfigResource) GetSpec() model.ResourceSpec {
	return t.Spec
}

func (t *ConfigResource) SetSpec(spec model.ResourceSpec) error {
	protoType, ok := spec.(*system_proto.Config)
	if !ok {
		return fmt.Errorf("invalid type %T for Spec", spec)
	} else {
		if protoType == nil {
			t.Spec = &system_proto.Config{}
		} else {
			t.Spec = protoType
		}
		return nil
	}
}

func (t *ConfigResource) Descriptor() model.ResourceTypeDescriptor {
	return ConfigResourceTypeDescriptor
}

var _ model.ResourceList = &ConfigResourceList{}

type ConfigResourceList struct {
	Items      []*ConfigResource
	Pagination model.Pagination
}

func (l *ConfigResourceList) GetItems() []model.Resource {
	res := make([]model.Resource, len(l.Items))
	for i, elem := range l.Items {
		res[i] = elem
	}
	return res
}

func (l *ConfigResourceList) GetItemType() model.ResourceType {
	return ConfigType
}

func (l *ConfigResourceList) NewItem() model.Resource {
	return NewConfigResource()
}

func (l *ConfigResourceList) AddItem(r model.Resource) error {
	if trr, ok := r.(*ConfigResource); ok {
		l.Items = append(l.Items, trr)
		return nil
	} else {
		return model.ErrorInvalidItemType((*ConfigResource)(nil), r)
	}
}

func (l *ConfigResourceList) GetPagination() *model.Pagination {
	return &l.Pagination
}

func (l *ConfigResourceList) SetPagination(p model.Pagination) {
	l.Pagination = p
}

var ConfigResourceTypeDescriptor = model.ResourceTypeDescriptor{
	Name:                ConfigType,
	Resource:            NewConfigResource(),
	ResourceList:        &ConfigResourceList{},
	ReadOnly:            false,
	AdminOnly:           false,
	Scope:               model.ScopeGlobal,
	KDSFlags:            model.GlobalToAllZonesFlag,
	WsPath:              "",
	DubboctlArg:         "",
	DubboctlListArg:     "",
	AllowToInspect:      false,
	IsPolicy:            false,
	SingularDisplayName: "Config",
	PluralDisplayName:   "Configs",
	IsExperimental:      false,
}

func init() {
	registry.RegisterType(ConfigResourceTypeDescriptor)
}

const (
	ZoneType model.ResourceType = "Zone"
)

var _ model.Resource = &ZoneResource{}

type ZoneResource struct {
	Meta model.ResourceMeta
	Spec *system_proto.Zone
}

func NewZoneResource() *ZoneResource {
	return &ZoneResource{
		Spec: &system_proto.Zone{},
	}
}

func (t *ZoneResource) GetMeta() model.ResourceMeta {
	return t.Meta
}

func (t *ZoneResource) SetMeta(m model.ResourceMeta) {
	t.Meta = m
}

func (t *ZoneResource) GetSpec() model.ResourceSpec {
	return t.Spec
}

func (t *ZoneResource) SetSpec(spec model.ResourceSpec) error {
	protoType, ok := spec.(*system_proto.Zone)
	if !ok {
		return fmt.Errorf("invalid type %T for Spec", spec)
	} else {
		if protoType == nil {
			t.Spec = &system_proto.Zone{}
		} else {
			t.Spec = protoType
		}
		return nil
	}
}

func (t *ZoneResource) Descriptor() model.ResourceTypeDescriptor {
	return ZoneResourceTypeDescriptor
}

var _ model.ResourceList = &ZoneResourceList{}

type ZoneResourceList struct {
	Items      []*ZoneResource
	Pagination model.Pagination
}

func (l *ZoneResourceList) GetItems() []model.Resource {
	res := make([]model.Resource, len(l.Items))
	for i, elem := range l.Items {
		res[i] = elem
	}
	return res
}

func (l *ZoneResourceList) GetItemType() model.ResourceType {
	return ZoneType
}

func (l *ZoneResourceList) NewItem() model.Resource {
	return NewZoneResource()
}

func (l *ZoneResourceList) AddItem(r model.Resource) error {
	if trr, ok := r.(*ZoneResource); ok {
		l.Items = append(l.Items, trr)
		return nil
	} else {
		return model.ErrorInvalidItemType((*ZoneResource)(nil), r)
	}
}

func (l *ZoneResourceList) GetPagination() *model.Pagination {
	return &l.Pagination
}

func (l *ZoneResourceList) SetPagination(p model.Pagination) {
	l.Pagination = p
}

var ZoneResourceTypeDescriptor = model.ResourceTypeDescriptor{
	Name:                ZoneType,
	Resource:            NewZoneResource(),
	ResourceList:        &ZoneResourceList{},
	ReadOnly:            false,
	AdminOnly:           false,
	Scope:               model.ScopeGlobal,
	WsPath:              "zones",
	DubboctlArg:         "zone",
	DubboctlListArg:     "zones",
	AllowToInspect:      false,
	IsPolicy:            false,
	SingularDisplayName: "Zone",
	PluralDisplayName:   "Zones",
	IsExperimental:      false,
}

func init() {
	registry.RegisterType(ZoneResourceTypeDescriptor)
}
